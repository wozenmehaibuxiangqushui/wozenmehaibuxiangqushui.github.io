<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux相关知识</title>
      <link href="/wozenmehaibuxiangqushui.github.io/2021/01/29/C-Linux%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/wozenmehaibuxiangqushui.github.io/2021/01/29/C-Linux%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux的基本介绍"><a href="#Linux的基本介绍" class="headerlink" title="Linux的基本介绍"></a>Linux的基本介绍</h1><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><p>Linux的应用领域很广，不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p><h2 id="与Windows的区别"><a href="#与Windows的区别" class="headerlink" title="与Windows的区别"></a>与Windows的区别</h2><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td><td>由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td>大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table><hr><h2 id="系统启动过程"><a href="#系统启动过程" class="headerlink" title="系统启动过程"></a>系统启动过程</h2><p>大致分为五个阶段：</p><ul><li>内核的引导。</li><li>运行 init。</li><li>系统初始化。</li><li>建立终端 。</li><li>用户登录系统。</li></ul><hr><h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><p>登录系统后，在当前命令窗口下输入命令：<code>ls /</code><br></p><p><strong><em>目录解释 :<br></em></strong></p><p><strong>系统启动：</strong></p><p>/boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p><p><strong><em>/etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。</em></strong></p><p>/lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p><p>/sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中。</p><p><strong>指令集合：</strong></p><p><strong><em>/bin：存放着最常用的程序和指令</em></strong><br><br><strong><em>/sbin：只有系统管理员能使用的程序和指令。</em></strong></p><p><strong>外部文件管理：</strong></p><p>/dev ：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。</p><p>/media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p><p>/mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。<br>临时文件：</p><p>/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p><p>/lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p><p>/tmp：这个目录是用来存放一些临时文件的。</p><p><strong>账户：</strong></p><p>/root：系统管理员的用户主目录。</p><p>/home：用户的主目录，以用户的账号命名的。</p><p>/usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p><p><strong><em>/usr/bin：系统用户使用的应用程序与指令。</em></strong></p><p><strong><em>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</em></strong></p><p>/usr/src：内核源代码默认的放置目录。</p><p><strong>运行过程中要用：</strong></p><p><strong><em>/var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</em></strong></p><p>/proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p><p><strong>扩展用的：</strong></p><p>/opt：默认是空的，我们安装额外软件可以放在这个里面。</p><p>/srv：存放服务启动后需要提取的数据（不用服务器就是空）</p><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="命令格式与目录处理命令ls"><a href="#命令格式与目录处理命令ls" class="headerlink" title="命令格式与目录处理命令ls"></a>命令格式与目录处理命令ls</h2><p>命令格式：<code>命令【-选项】【参数】</code><br></p><blockquote><p>例：ls -la /etc</p></blockquote><p>说明：</p><ul><li><p>个别命令不用遵守此格式</p></li><li><p>当有多个选项时，可以写在一起</p></li><li><p>简化选项与完整选项 </p><blockquote><p>如：-a 等于 -all</p></blockquote></li><li><p>–</p></li></ul><h2 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>命令名称：ls<br><br>命令英文原意：list<br><br>命令所在路径：/bin/ls<br><br>执行权限：所有用户<br><br>语法：<code>ls 选项[-ald] [文件或目录] </code><br><br>用途：显示目录中内容，包括子目录和文件相关属性信息<br></p><p>常用选项：</p><ul><li>a 显示所有文件，主要是显示出隐藏文件(all)</li><li>l 详细信息显示(long)</li><li>d 仅查看指定目录属性</li><li>h 人性化显示（单位）(human)</li><li>i i结点，表达文件的索引号</li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>命令英文原意：make directories<br><br>命令所在路径：/bin/makir<br><br>执行权限：所有用户<br><br>语法：<code>makir -p [目录名]</code><br><br>功能描述：创建新目录 -p：递归创建<br><br>递归创建是指连续创建各个子目录</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>命令英文原意：change directory<br><br>命令所在路径：shell内置命令<br><br>执行权限：所有用户<br><br>语法：<code>cd [目录]</code><br><br>功能描述：切换目录<br></p><blockquote><p>范例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;tem&#x2F;Japan 切换到指定目录</span><br><span class="line">cd … 回到上一级目录（…为上一级目录，.为当前目录）</span><br></pre></td></tr></table></figure><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>命令英文原意：print working directory<br><br>命令所在路径：/bin/pwd<br><br>执行权限：所有用户<br><br>语法：<code>pwd</code>（直接在命令行打入这个命令即可）<br><br>功能描述：显示当前目录<br><br>范例：<br><code>$ pwd</code></p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>命令英文原意：copy<br><br>命令所在路径：/bin/cp<br><br>执行权限：所有用户<br><br>语法：<code>cp -rp [原文件或目录] [目标目录]</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r 复制目录（单纯为目录时用-r，即对象不是一个文件）</span><br><span class="line">-p 保留文件属性（若保留原文件属性，如时间用-p）</span><br></pre></td></tr></table></figure><p>功能描述：复制文件或目录<br></p><p>注意：</p><ul><li>可以同时复制多个文件到指定目录</li><li>可以在拷贝过去的同时修改文件名，只需要在结尾改成需要的名字</li></ul><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>命令英文原意：move<br><br>命令所在路径：/bin/mv<br><br>执行权限：所有用户<br><br>语法：<code>mv [原文件或目录] [目标目录]</code> 或<code>mv [文件原名] [文件新名字]</code><br><br>功能描述：剪切文件、改名（所谓改名，就是在同一个目录下）</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>命令英文原意：remove<br><br>命令所在路径：/bin/rm<br><br>执行权限：所有用户<br><br>语法：<code>rm -rf [文件或目录]</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r 删除目录（删除目录时必须加-r）</span><br><span class="line">-f 强制执行（不询问是否删除）</span><br></pre></td></tr></table></figure><p>功能描述：剪切文件、改名（所谓改名，就是在同一个目录下）</p><hr><h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>命令所在路径：/bin/touch<br><br>执行权限：所有用户<br><br>语法：<code>touch [文件名/路径到文件名]</code><br><br>功能描述：创建空文件<br><br>范例：<code>$ touch SLAM.list</code><br><br>注意：不要使用空格作为文件名，否则要用双引号引起来</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>命令所在路径：/bin/cat<br><br>执行权限：所有用户<br><br>语法：<code>cat -n [文件名]</code><br><br>功能描述：显示文件内容，即浏览文件内容<br></p><figure class="highlight plain"><figcaption><span>显示行号```<br></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范例：</span><br></pre></td></tr></table></figure><p>$ cat /etc/issue<br>$ cat -n /etc/services</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tac命令可以反向显示文件内容，用法和cat完全一样，但不支持-n</span><br><span class="line"></span><br><span class="line">### more</span><br><span class="line">命令所在路径：&#x2F;bin&#x2F;more&lt;br&gt;</span><br><span class="line">执行权限：所有用户&lt;br&gt;</span><br><span class="line">语法：&#96;&#96;&#96;cat [文件名]&#96;&#96;&#96;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>（空格）或f 翻页<br>（enter） 换行<br>q或Q 退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">功能描述：分页显示文件内容&lt;br&gt;</span><br><span class="line">范例：</span><br><span class="line">&#96;&#96;&#96;$ more &#x2F;etc&#x2F;services&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">### less</span><br><span class="line">命令所在路径：&#x2F;usr&#x2F;bin&#x2F;less&lt;br&gt;</span><br><span class="line">执行权限：所有用户&lt;br&gt;</span><br><span class="line">语法：&#96;&#96;&#96;less [文件名]&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">功能描述：分页显示文件内容（可向上翻页）</span><br></pre></td></tr></table></figure><p>操作类似more，可以用上键/pageup向上翻页<br>在less界面，可以打一个/，之后打入你想要的内容进行搜索<br>搜索到后可以使用n进行向下检索（next）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">范例：</span><br><span class="line">&#96;&#96;&#96;$ less &#x2F;etc&#x2F;service&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">### head</span><br><span class="line">命令所在路径：&#x2F;usr&#x2F;bin&#x2F;head&lt;br&gt;</span><br><span class="line">执行权限：所有用户</span><br><span class="line">语法：&#96;&#96;&#96;head [文件名]&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">功能描述：显示文件的前几行，默认显示前十行&lt;br&gt;</span><br><span class="line">&#96;&#96;&#96;-n 指定行数&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">范例：</span><br></pre></td></tr></table></figure><p>$ head -n 20 /etc/services</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tail命令可以显示末尾的n行，-f可以动态显示</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 链接命令</span><br><span class="line"></span><br><span class="line">### ln</span><br><span class="line">命令英文原意：link&lt;br&gt;</span><br><span class="line">命令所在路径：&#x2F;bin&#x2F;ln&lt;br&gt;</span><br><span class="line">执行权限：所有用户&lt;br&gt;</span><br><span class="line">语法：&#96;&#96;&#96;ln -s [原文件] [目标文件]&#96;&#96;&#96;&lt;br&gt;</span><br></pre></td></tr></table></figure><p>-s 创建软链接，否则为硬链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能描述：生成链接文件&lt;br&gt;</span><br><span class="line">范例：</span><br><span class="line">&#96;&#96;&#96;$ ln -s &#x2F;etc&#x2F;issue &#x2F;tmp&#x2F;issue.soft&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">指令解析：</span><br></pre></td></tr></table></figure><p>软链接相当于win下的快捷方式，体积很小，具有所有rwx权限，ls显示会在开头出现l，且有箭头指向原文件<br>硬链接相当于一个影子文件，与cp类似，不过cp之后再操作不会影响原文件，但硬链接会影响<br>硬链接与原文件i结点相同，cp后的文件不同<br>硬链接不能跨分区，且只针对目录使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">## 权限管理命令</span><br><span class="line">## chmod</span><br><span class="line">命令名称：chmod&lt;br&gt;</span><br><span class="line">命令英文原意：change the permissions mode of a file&lt;br&gt;</span><br><span class="line">命令所在路径：&#x2F;bin&#x2F;chmod&lt;br&gt;</span><br><span class="line">执行权限：所有用户&lt;br&gt;</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>chmod [ {ugoa}{±=}{rwx} ] [文件或目录]<br>chmod [mode=421] [文件或目录]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">*-R 递归修改*&lt;br&gt;</span><br><span class="line">功能描述：改变文件或目录的权限&lt;br&gt;</span><br><span class="line">指令解析：</span><br><span class="line">- 可以对不同类型的用户进行同时修改权限，加逗号隔开即可（±&#x3D;方式并不常用）</span><br><span class="line">- 递归修改是指对目录下所有文件的权限都进行了修改</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 其他权限管理命令</span><br><span class="line">### chown</span><br><span class="line">命令英文原意：change file ownership&lt;br&gt;</span><br><span class="line">命令所在路径：&#x2F;bin&#x2F;chmod&lt;br&gt;</span><br><span class="line">执行权限：所有用户&lt;br&gt;</span><br><span class="line">语法：&#96;&#96;&#96;chown [用户] [文件或目录]&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">功能描述：改变文件或目录的所有者&lt;br&gt;</span><br><span class="line">范例：&#96;&#96;&#96;$ chown llh study（改变文件study的所有者为llh）&#96;&#96;&#96;</span><br><span class="line">- 改变文件权限，只能是所有者或者管理员root</span><br><span class="line">- 在一个目录下，可以使用“useradd [文件名]”来创建一个新的所有者，这与之前的涉及的所有者所属组是谁有关系了</span><br><span class="line"></span><br><span class="line">### chgrp</span><br><span class="line">使用方法与chown完全一致&lt;br&gt;</span><br><span class="line">也有添加所属组的命令，即groupadd</span><br><span class="line"></span><br><span class="line">### umask</span><br><span class="line">命令英文原意：the user file-creation mask&lt;br&gt;</span><br><span class="line">命令所在路径：Shell内置命令&lt;br&gt;</span><br><span class="line">执行权限：所有用户&lt;br&gt;</span><br><span class="line">语法：&#96;&#96;&#96;umask [-S]&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">*-S 以rwx形式显示新建文件或目录缺省权限*&lt;br&gt;</span><br><span class="line">功能描述：显示、设置文件的缺省权限&lt;br&gt;</span><br><span class="line">范例：&#96;&#96;&#96;$ umask -S&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">- 一个用户创建文件时，他的所属组，就是用户的缺省（默认）组</span><br><span class="line">- Linux系统中任何新建的文件都没有可执行权限</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 文件搜索命令</span><br><span class="line">### find</span><br><span class="line">***尽量不要用搜索命令，占用资源太大***&lt;br&gt;</span><br><span class="line">命令所在路径：&#x2F;bin&#x2F;find&lt;br&gt;</span><br><span class="line">执行权限：所有用户&lt;br&gt;</span><br><span class="line">语法：&#96;&#96;&#96;find [搜索范围] [匹配条件]&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">功能描述：文件搜索&lt;br&gt;</span><br><span class="line">范例：</span><br></pre></td></tr></table></figure><p>$ find /etc -name init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">在目录&#x2F;etc中查找文件init</span><br><span class="line">若把init改成init，包含init四个字母的就都会被找到，否则只能找到就叫init的文件</span><br><span class="line">哪边有*符号，则可以找这边有其他字符的名字</span><br><span class="line">若改为init???，就会找到init开头，后边有三个字母的文件</span><br><span class="line">严格区分大小写</span><br><span class="line">-name改为-iname就会不再区分大小写查找</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -size +204800</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在根目录下查找大于100Mb的文件</span><br><span class="line">要把文件大小换算为数据块：1数据块&#x3D;512字节&#x3D;0.5k</span><br><span class="line">+n：大于 -n：小于 n：等于</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F;home -user lihaha</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在根目录下查找所有者为lihaha的文件</span><br><span class="line">-group 根据所属组查找</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F;etc -cmin -5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在&#x2F;etc下查找5分钟内被修改过属性的文件和目录</span><br><span class="line">-amin：访问时间（access）</span><br><span class="line">-cmin：文件属性（change）</span><br><span class="line">-mmin：文件内容（modify）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F;etc -size +163840 -a -size -204800</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在&#x2F;etc下查找大于80Mb小于100Mb的文件</span><br><span class="line">-a：两个条件同时满足</span><br><span class="line">-o：两个条件满足任意一个即可</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;etc -size +163840 -a -type f</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在&#x2F;etc目录下查找大于80Mb的文件，-type 根据文件类型查找</span><br><span class="line">f：文件 d：目录 l：软连接文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;etc -name inittab -exec ls -l &#123;&#125; ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在&#x2F;etc下查找inittab文件并显示其详细信息其他文件搜索命令</span><br><span class="line">-exec&#x2F;-ok 命令 &#123;&#125; ;</span><br><span class="line">是一种固定格式，即在找到文件后执行后边的命令</span><br><span class="line">-exec是直接显示，-ok是对每一个找到的目标进行询问确认</span><br><span class="line">-inum 根据i节点查找</span><br><span class="line">可以根据i节点进行删除</span><br></pre></td></tr></table></figure><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>用途：查找命令文件存放目录<br><br>搜索范围由环境变量PATH决定（echo $PATH）<br><br><code>which 命令|程序名 //默认当找到第一个目标后不再继续查找</code><br>或<br><code>which -a 命令|程序名 //在所有搜索路径中查找</code></p><p>示例：</p><blockquote></blockquote><p>which ls<br><br>which history<br><br>使用which查找内部命令时，将找不到对应的程序</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>Linux常用命令：</p></li><li><p>查看及切换目录（pwd、cd、ls、du）</p></li><li><p>创建目录和文件（mkdir、touch、ln）</p></li><li><p>复制、删除、移动目录和文件（cp、rm、mv）</p></li><li><p>查找目录和文件（which、find）</p></li><li><p>快捷键</p></li><li><p>clear/Ctrl+l：可以清除命令行中的痕迹</p></li><li><p>Ctrl+c：终止命令行当前操作</p></li><li><p>快捷键Ctrl+h：在一个文件夹中打开这个，可以看该文件夹下的隐藏文件</p></li><li><p>tree：显示当前目录下目录结构</p></li><li><p>–</p></li></ul><h2 id="其他文件搜索命令"><a href="#其他文件搜索命令" class="headerlink" title="其他文件搜索命令"></a>其他文件搜索命令</h2><h3 id="快速资料库文件搜索：locate"><a href="#快速资料库文件搜索：locate" class="headerlink" title="快速资料库文件搜索：locate"></a>快速资料库文件搜索：locate</h3><p>命令所在路径：/usr/bin/locate<br><br>执行权限：所有用户<br><br>语法：<code>locate 文件名</code><br><br>功能描述：在文件资料库中查找文件<br></p><blockquote><p>locate inti</p></blockquote><ul><li>系统创建了一个资料库，搜索速度非常快</li><li>然而对于新创建的文件，资料库未更新，find就不存在这种问题<br>使用如下命令即可更新文件资料库：</li></ul><blockquote><p>updatedb</p></blockquote><ul><li>对于/tmp目录不在文件资料库中，无法寻找到</li><li>可以使用-i不再区分大小写</li></ul><blockquote><p>lacate -i init</p></blockquote><p>命令路径搜索命令：which<br><br>执行权限：所有用户<br><br>语法：<code>which 命令名</code><br><br>功能描述：搜索命令所在目录及别名信息</p><blockquote><p>which cp</p></blockquote><p>将显示cp目录所在位置和cp命令的别名</p><h3 id="命令目录及帮助文档搜索命令：whereis"><a href="#命令目录及帮助文档搜索命令：whereis" class="headerlink" title="命令目录及帮助文档搜索命令：whereis"></a>命令目录及帮助文档搜索命令：whereis</h3><p>命令所在路径：/usr/bin/whereis&lt;br》<br>执行权限：所有用户<br><br>语法：<code>whereis [命令名称]</code><br><br>功能描述：搜索命令所在目录及帮助文档路径</p><hr><h2 id="关机和重启命令"><a href="#关机和重启命令" class="headerlink" title="关机和重启命令"></a>关机和重启命令</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>命令名称：shutdown<br><br>英文原意：bring the system down<br><br>所在路径：/sbin/shutdown<br><br>执行权限：超级用户<br><br>功能描述：关机和重启<br><br>命令格式</p><figure class="highlight plain"><figcaption><span>~]# shutdown [选项] 时间 [警告信息]```<br></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">选项:</span><br><span class="line">- -c：取消已经执行的 shutdown 命令；</span><br><span class="line">- -h：关机；</span><br><span class="line">- -r：重启；</span><br><span class="line"></span><br><span class="line">### reboot</span><br><span class="line">表示立即重启，效果等同于 &#96;&#96;&#96;shutdown -r now&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><p>[root@localhost ~]# reboot<br>#重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### halt和poweroff命令</span><br></pre></td></tr></table></figure><p>[root@localhost ~】# halt<br>//不理会目前系统状况下，进行硬件关机，一般不建议使用<br>[root@localhost ~】# poweroff<br>//poweroff表示立即关机，效果等同于shutdown -h now，在多用户模式下(Run Level 3）不建议使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### init</span><br><span class="line">init 是修改 Linux 运行级别的命令，也可以用于关机和重启。</span><br></pre></td></tr></table></figure><p>[root@localhost~]# init 0<br>#关机，也就是调用系统的 0 级别<br>[root@localhost ~】# init 6<br>#重启，也就是调用系统的 6 级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 用户管理</span><br><span class="line">步骤：</span><br><span class="line">- 户账号的添加、删除与修改。</span><br><span class="line">- 用户口令的管理。</span><br><span class="line">- 用户组的管理。</span><br><span class="line"></span><br><span class="line">### useradd</span><br><span class="line">用途：添加新的用户账号&lt;br&gt;</span><br><span class="line">语法：&#96;&#96;&#96;useradd 选项 用户名&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">选项:</span><br></pre></td></tr></table></figure><p>-c comment 指定一段注释性描述。<br>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g 用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s Shell文件 指定用户的登录Shell。<br>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### userdel</span><br><span class="line">用途：删除帐号&lt;br&gt;</span><br><span class="line">格式: &#96;&#96;&#96;userdel 选项 用户名&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">&gt;常用的选项是 -r，它的作用是把用户的主目录一起删除。&lt;br&gt;</span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#userdel -r sam //此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">### usermod</span><br><span class="line">用途：修改用户账号&lt;br&gt;</span><br><span class="line">格式: &#96;&#96;&#96;usermod 选项 用户名&#96;&#96;&#96;</span><br><span class="line">常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</span><br><span class="line"></span><br><span class="line">另外，有些系统可以使用选项：-l 新用户名</span><br><span class="line"></span><br><span class="line">这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</span><br><span class="line"></span><br><span class="line">### passwd</span><br><span class="line">用途：用户口令的管理&lt;br&gt;</span><br><span class="line">格式: &#96;&#96;&#96;passwd 选项 用户名&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">选项：</span><br><span class="line">- -l 锁定口令，即禁用账号。</span><br><span class="line">- -u 口令解锁。</span><br><span class="line">- -d 使账号无口令。</span><br><span class="line">- -f 强迫用户下次登录时修改口令。&lt;br&gt;</span><br><span class="line">*如果默认用户名，则修改当前用户的口令。*</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 用户组管理</span><br><span class="line">### groupadd</span><br><span class="line">用途：增加一个新的用户组&lt;br&gt;</span><br><span class="line">格式: &#96;&#96;&#96;groupadd 选项 用户组&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">- -g GID 指定新用户组的组标识号（GID）。</span><br><span class="line">- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</span><br><span class="line"></span><br><span class="line">### groupdel</span><br><span class="line">用途: 删除一个已有的用户组&lt;br&gt;</span><br><span class="line">格式: &#96;&#96;&#96;groupdel 用户组&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### groupmod</span><br><span class="line">用途:修改用户组的属性&lt;br&gt;</span><br><span class="line">语法: &#96;&#96;&#96;groupmod 选项 用户组&#96;&#96;&#96;&lt;br&gt;</span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">- -g GID 为用户组指定新的组标识号。</span><br><span class="line">- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class="line">- -n新用户组 将用户组的名字改为新名字</span><br><span class="line"></span><br><span class="line">### newgrp</span><br><span class="line">用途:切换到其他用户组&lt;br&gt;</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><p>$ newgrp root //将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">## 磁盘管理</span><br><span class="line">### df</span><br><span class="line">用途：列出文件系统的整体磁盘使用量&lt;br&gt;</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>df [-ahikHTm] [目录或文件名]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br></pre></td></tr></table></figure><p>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；<br>-k ：以 KBytes 的容量显示各文件系统；<br>-m ：以 MBytes 的容量显示各文件系统；<br>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；<br>-H ：以 M=1000K 取代 M=1024K 的进位方式；<br>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；<br>-i ：不用硬盘容量，而以 inode 的数量来显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### du</span><br><span class="line">用途：检查磁盘空间使用量&lt;br&gt;</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>du [-ahskm] 文件或目录名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br></pre></td></tr></table></figure><p>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。<br>-h ：以人们较易读的容量格式 (G/M) 显示；<br>-s ：列出总量而已，而不列出每个各别的目录占用容量；<br>-S ：不包括子目录下的总计，与 -s 有点差别。<br>-k ：以 KBytes 列出容量显示；<br>-m ：以 MBytes 列出容量显示；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### fdisk</span><br><span class="line">用途：用于磁盘分区&lt;br&gt;</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>fdisk [-l] 装置名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line"></span><br><span class="line">-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来</span><br><span class="line">###  mkfs</span><br><span class="line">全称：make filesystem&lt;br&gt;</span><br><span class="line">用途：磁盘格式化&lt;br&gt;</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>mkfs [-t 文件系统格式] 装置文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line"></span><br><span class="line">-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)</span><br><span class="line">### fsck</span><br><span class="line">全称：file system check&lt;br&gt;</span><br><span class="line">用途：磁盘检验&lt;br&gt;</span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>fsck [-t 文件系统] [-ACay] 装置名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br></pre></td></tr></table></figure><p>-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数<br>-s : 依序一个一个地执行 fsck 的指令来检查<br>-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查<br>-C : 显示完整的检查进度<br>-d : 打印出 e2fsck 的 debug 结果<br>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行<br>-R : 同时有 -A 条件时，省略 / 不检查<br>-V : 详细显示模式<br>-a : 如果检查有错则自动修复<br>-r : 如果检查有错则由使用者回答是否修复<br>-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">###  mount</span><br><span class="line">用途：磁盘挂载与卸除&lt;br&gt; </span><br><span class="line">语法：</span><br></pre></td></tr></table></figure><p>mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点 //磁盘挂载<br>umount [-fn] 装置文件名或挂载点 //磁盘卸载命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">## 进程管理</span><br><span class="line">### top</span><br><span class="line"></span><br><span class="line">### htop</span><br><span class="line">没有的话则先—— sudo apt-get install htop（apt-get 安装原理？））</span><br><span class="line"></span><br><span class="line">### ps</span><br></pre></td></tr></table></figure><p>ps -A | grep firefox　　ps -A | less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### pstree</span><br><span class="line"></span><br><span class="line">### kill  </span><br><span class="line">kill pid 　（kill -KILL或者kill -9 来杀死顽固的进程）</span><br><span class="line"></span><br><span class="line">### pgrep</span><br><span class="line">寻找进程ID ，与kill 结合—— kill $（pgrep lantern）</span><br><span class="line"></span><br><span class="line">### pkill &amp; killall</span><br><span class="line">pkill lantern &lt;&#x3D;&gt; killall lantern &lt;&#x3D;&gt; pgrep lantern</span><br><span class="line"></span><br><span class="line">### renice </span><br><span class="line">renice 19 pid (改变优先级—— -19非常高， 19非常低，0默认的优先级)</span><br><span class="line"></span><br><span class="line">### xkill</span><br><span class="line">高级图形杀，左键点到之处killed，右键取消</span><br><span class="line"></span><br><span class="line">### gnome-system-monitor </span><br><span class="line">图形化的资源管理器</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># vim编辑器</span><br><span class="line">## 简介</span><br><span class="line">Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## vi&#x2F;vim 的使用</span><br><span class="line">基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</span><br><span class="line"></span><br><span class="line">**命令模式：**</span><br><span class="line">- 用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</span><br><span class="line"></span><br><span class="line">- 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</span><br><span class="line"></span><br><span class="line">- 以下是常用的几个命令：</span><br><span class="line"></span><br><span class="line"> - i 切换到输入模式，以输入字符。&lt;br&gt;</span><br><span class="line"> - x 删除当前光标所在处的字符。&lt;br&gt;</span><br><span class="line"> - : 切换到底线命令模式，以在最底一行输入命令。&lt;br&gt;</span><br><span class="line">若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。&lt;br&gt;</span><br><span class="line"></span><br><span class="line"> 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</span><br><span class="line"></span><br><span class="line">**输入模式**</span><br><span class="line">- 在命令模式下按下i就进入了输入模式。</span><br><span class="line"></span><br><span class="line">- 在输入模式中，可以使用以下按键：</span><br><span class="line"></span><br><span class="line">- 字符按键以及Shift组合，输入字符</span><br><span class="line"> - ENTER，回车键，换行</span><br><span class="line"> - BACK SPACE，退格键，删除光标前一个字符</span><br><span class="line"> - DEL，删除键，删除光标后一个字符</span><br><span class="line"> - 方向键，在文本中移动光标</span><br><span class="line"> - HOME&#x2F;END，移动光标到行首&#x2F;行尾</span><br><span class="line"> - Page Up&#x2F;Page Down，上&#x2F;下翻页</span><br><span class="line"> - Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</span><br><span class="line"> -  ESC，退出输入模式，切换到命令模式&lt;br&gt;</span><br><span class="line"></span><br><span class="line">**底线命令模式**&lt;br&gt;</span><br><span class="line">- 在命令模式下按下:（英文冒号）就进入了底线命令模式。</span><br><span class="line"></span><br><span class="line">- 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</span><br><span class="line"></span><br><span class="line">- 在底线命令模式中，基本的命令有（已经省略了冒号）：</span><br><span class="line"></span><br><span class="line"> - q 退出程序</span><br><span class="line"> - w 保存文件</span><br><span class="line"> - 按ESC键可随时退出底线命令模式。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># yum 命令</span><br><span class="line">yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</span><br><span class="line"></span><br><span class="line">基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</span><br><span class="line"></span><br><span class="line">yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</span><br><span class="line"></span><br><span class="line">##  语法</span><br></pre></td></tr></table></figure><p>yum [options] [command] [package …]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 &quot;yes&quot;），-q（不显示安装的过程）等等。</span><br><span class="line">command：要进行的操作。</span><br><span class="line">package：安装的包名。</span><br></pre></td></tr></table></figure><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li><p>列出所有可更新的软件清单命令：yum check-update</p></li><li><p>更新所有软件命令：yum update</p></li><li><p>仅安装指定的软件命令：yum install <package_name></p></li><li><p>仅更新指定的软件命令：yum update <package_name></p></li><li><p>列出所有可安裝的软件清单命令：yum list</p></li><li><p>删除软件包命令：yum remove <package_name></p></li><li><p>查找软件包命令：yum search <keyword></p></li><li><p>清除缓存命令:</p></li></ol><ul><li>yum clean packages: 清除缓存目录下的软件包</li><li>yum clean headers: 清除缓存目录下的 headers</li><li>yum clean oldheaders: 清除缓存目录下旧的 headers</li><li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers</li></ul><hr><h1 id="apt-命令"><a href="#apt-命令" class="headerlink" title="apt 命令"></a>apt 命令</h1><p>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p><p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>apt 命令执行需要超级管理员权限(root)。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt [options] [command] [package ...]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options：可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。</span><br><span class="line">command：要进行的操作。</span><br><span class="line">package：安装的包名。</span><br></pre></td></tr></table></figure><h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><p>列出所有可更新的软件清单命令：<code>sudo apt update</code></p><p>升级软件包：<code>sudo apt upgrade</code></p><p>列出可更新的软件包及版本信息：<code>apt list --upgradeable</code></p><p>升级软件包，升级前先删除需要更新软件包：<code>sudo apt full-upgrade</code></p><p>安装指定的软件命令：<code>sudo apt install &lt;package_name&gt;</code></p><p>安装多个软件包：<code>sudo apt install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt;</code></p><p>更新指定的软件命令：<code>sudo apt update &lt;package_name&gt;</code></p><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<code>sudo apt show &lt;package_name&gt;</code></p><p>删除软件包命令：<code>sudo apt remove &lt;package_name&gt;</code></p><p>清理不再使用的依赖和库文件: <code>sudo apt autoremove</code></p><p>移除软件包及配置文件: <code>sudo apt purge &lt;package_name&gt;</code></p><p>查找软件包命令：<code> sudo apt search &lt;keyword&gt;</code></p><p>列出所有已安装的包：<code>apt list --installed</code></p><p>列出所有已安装的包的版本信息：<code>apt list --all-versions</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++（二）</title>
      <link href="/wozenmehaibuxiangqushui.github.io/2021/01/24/C-%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/wozenmehaibuxiangqushui.github.io/2021/01/24/C-%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、C-基础入门（二）"><a href="#一、C-基础入门（二）" class="headerlink" title="一、C++基础入门（二）"></a>一、C++基础入门（二）</h1><h2 id="（一）指针"><a href="#（一）指针" class="headerlink" title="（一）指针"></a>（一）指针</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p><strong>指针的作用</strong>：可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进数字表示</li><li>可以利用指针变量保存地址</li></ul><hr><h3 id="2、变量的定义和使用"><a href="#2、变量的定义和使用" class="headerlink" title="2、变量的定义和使用"></a>2、变量的定义和使用</h3><p>语法的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型*变量名；</span><br></pre></td></tr></table></figure><hr><h3 id="3、所占内存空间"><a href="#3、所占内存空间" class="headerlink" title="3、所占内存空间"></a>3、所占内存空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在32位操作系统中，指针占4个字节空间大小；</span><br><span class="line">在64位操作系统中，指针占8个字节空间大小；</span><br><span class="line">不管是什么数据类型；</span><br></pre></td></tr></table></figure><hr><h3 id="4、空指针和野指针"><a href="#4、空指针和野指针" class="headerlink" title="4、空指针和野指针"></a>4、空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间，用于初始化指针变量</p><ul><li>空指针指向的内存是不可以访问的（**<em>0~255之间的内存编号是系统占用的，因此不可访问**</em>）</li></ul><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><p><em>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</em></p><hr><h3 id="5、const修饰指针"><a href="#5、const修饰指针" class="headerlink" title="5、const修饰指针"></a>5、const修饰指针</h3><p>有三种情况：</p><ul><li>const修饰指针 —- 常量指针<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针的指向可以修改，但是指针指向的值不可以改</span><br></pre></td></tr></table></figure><blockquote><p>示例<br><br>const int * p1 = &a;<br></p></blockquote></li></ul><p> <em>p1 = &b;//正确<br><br> **</em>p2 = 100;//错误</p><ul><li>const修饰常量 —- 指针常量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针的指向不可以改，指针指向的值可以改</span><br></pre></td></tr></table></figure><blockquote><p>示例<br><br>int * const p2 = &a;<br><br>p2 = &b;//错误<br></p></blockquote></li></ul><p> **p2 = 100;//正确<br></p><ul><li>const即修饰指针，又修饰常量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针的指向和指针指向的值都不可以改</span><br></pre></td></tr></table></figure><blockquote><p>示例<br><br>const int * const p3 = &a;<br><br>p3 = &b;//错误<br></p></blockquote></li></ul><p> **p3 = &a;//错误</p><p> <em>技巧：看const右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量</em></p><hr><h3 id="6、指针和数组"><a href="#6、指针和数组" class="headerlink" title="6、指针和数组"></a>6、指针和数组</h3><p> 作用：利用指针访问数组中元素</p><blockquote><p>示例</p></blockquote><blockquote><pre><code>int main()&#123;   int arr[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int * p = arr;//指向数组的指针 cout&lt;&lt;&quot;第一个元素：&quot;&lt;&lt;arr[0]&lt;&lt;endl; cout&lt;&lt;&quot;指针访问第一个元素：&quot;&lt;&lt;*p&lt;&lt;endl; for(int i = 0;i&lt;10;i++) &#123; //利用指针遍历数组 cout&lt;&lt;*p&lt;&lt;endl; p++; &#125; system(&quot;pause&quot;); return 0;</code></pre></blockquote><hr><h3 id="7、指针和函数"><a href="#7、指针和函数" class="headerlink" title="7、指针和函数"></a>7、指针和函数</h3><p>作用：利用指针作函数参数，可以修改实参的值</p><blockquote><p>示例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;值传递</span><br><span class="line">void swap(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;地址传递</span><br><span class="line">void swap2(int * p1,int * p2)</span><br><span class="line">&#123;</span><br><span class="line">int temp &#x3D; *p1;</span><br><span class="line">*p1 &#x3D; *p2;</span><br><span class="line">*p2 &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; 20;</span><br><span class="line">swap1(a,b);&#x2F;&#x2F;值传递不会改变实参</span><br><span class="line">swap2(&amp;a,&amp;b);&#x2F;&#x2F;地址传递会改变实参</span><br><span class="line">cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><blockquote><p>不想改变实参用值传递，想改变实参就用地址传递</p></blockquote><hr><h3 id="8、指针、数组、函数"><a href="#8、指针、数组、函数" class="headerlink" title="8、指针、数组、函数"></a>8、指针、数组、函数</h3><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序<br>主要步骤：</p><ul><li><p>创建数组</p></li><li><p>创建函数，实现冒泡排序</p></li><li><p>打印排序后的数组</p><blockquote><p>示例</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[10] &#x3D; &#123;4,3,6,9,1,2,10,8,7,5&#125;;&#x2F;&#x2F;数组长度</span><br><span class="line">int len &#x3D; sizeof(arr)&#x2F;sizeof(arr[10]);</span><br><span class="line">bubbleSort(arr,len);</span><br><span class="line">printfArray(arr,len);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure></li><li><p>–</p><h2 id="二）结构体"><a href="#二）结构体" class="headerlink" title="(二）结构体"></a>(二）结构体</h2><h3 id="1、基本概念-1"><a href="#1、基本概念-1" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p>属于用户**<em>自定义的数据类型**</em>，允许用户存储不同的数据类型</p></li><li><p>–</p><h3 id="2、定义和使用"><a href="#2、定义和使用" class="headerlink" title="2、定义和使用"></a>2、定义和使用</h3><p>语法：<code>struct 结构体名&#123;结构体成员列表&#125;；</code><br><br>通过结构体创建变量的方式有三种：</p></li><li><p>struct结构体名 变量名</p></li><li><p>struct结构体名 变量名={成员1值，成员2值…}</p></li><li><p>定义结构体时顺便创建变量</p><p> <em>注：<br><br>1）定义结构体时的关键字是 struct，不可省略<br><br>2）创建结构体变量时，关键字 struct可以省略<br><br>3）结构体变量利用操作符”.”访问成员</em></p></li><li><p>–</p><h3 id="3、结构体数组"><a href="#3、结构体数组" class="headerlink" title="3、结构体数组"></a>3、结构体数组</h3><p>作用：将自定义的结构体放入数组中方便维护<br><br>语法：<code>struct 结构体名 数组名[元素个数] = &#123; &#123;&#125;,&#123;&#125;,...&#123;&#125; &#125;</code><br><br>主要步骤：</p></li><li><p>定义结构体</p></li><li><p>创建结构体数组</p></li><li><p>给结构体数组中的元素赋值</p></li><li><p>遍历结构体数组</p></li><li><p>–</p><h3 id="4、结构体指针"><a href="#4、结构体指针" class="headerlink" title="4、结构体指针"></a>4、结构体指针</h3><p>作用：通过指针访问结构体中的成员（可利用操作符<code>-&gt;</code>通过结构体指针访问结构体属性，结构体指针可以通过<code>-&gt;</code>来访问结构体中的成员）<br><br>主要步骤：</p></li><li><p>创建结构体变量</p></li><li><p>通过指针指向结构体变量</p></li><li><p>通过指针访问结构体变量中的数据</p></li><li><p>–</p><h3 id="5、结构体嵌套结构体"><a href="#5、结构体嵌套结构体" class="headerlink" title="5、结构体嵌套结构体"></a>5、结构体嵌套结构体</h3><p>作用：结构体中的成员可以是另一个结构体<br></p><p>注意：在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p></li><li><p>–</p><h3 id="6、结构体做函数参数"><a href="#6、结构体做函数参数" class="headerlink" title="6、结构体做函数参数"></a>6、结构体做函数参数</h3><p>作用：将结构体作为参数向函数中传递<br></p><p>传递方式：</p></li><li><p> 值传递</p></li><li><p>地址传递</p><p>如果不想修改主函数中的数据，用值传递，反之用地址传递</p></li><li><p>–</p><h3 id="7、结构体中const使用场景"><a href="#7、结构体中const使用场景" class="headerlink" title="7、结构体中const使用场景"></a>7、结构体中const使用场景</h3><p>作用：用const来防止误操作<br></p></li></ul><p> <em>示例</em><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;学生结构体定义</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;成员列表</span><br><span class="line">string name;&#x2F;&#x2F;姓名</span><br><span class="line">int age;   &#x2F;&#x2F;年龄</span><br><span class="line">int score; &#x2F;&#x2F;分数</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;const使用场景</span><br><span class="line">void printStudent(const student *stu)&#x2F;&#x2F;加const防止函数体中的误操作</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;stu-&gt;age &#x3D; 100;&#x2F;&#x2F;操作失败，因为加了const修饰</span><br><span class="line">cout&lt;&lt;&quot;姓名&quot;&lt;&lt;stu-&gt;name&lt;&lt;&quot;年龄&quot;&lt;&lt;stu-&gt;age&lt;&lt;&quot;分数&quot;&lt;&lt;stu-&gt;score&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">student stu &#x3D; &#123; &quot;张三&quot;,18,100 &#125;;</span><br><span class="line">printStudent(&amp;stu);</span><br><span class="line">system(&quot;pause&quot;;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure></p><hr><h1 id="二、案例：通讯管理系统"><a href="#二、案例：通讯管理系统" class="headerlink" title="二、案例：通讯管理系统"></a>二、案例：通讯管理系统</h1><h2 id="一）系统需求"><a href="#一）系统需求" class="headerlink" title="(一）系统需求"></a>(一）系统需求</h2><h4 id="功能实现："><a href="#功能实现：" class="headerlink" title="功能实现："></a>功能实现：</h4><ul><li>添加联系人：添加新人（信息包括姓名、性别、年龄、联系电话、家庭住址等）最多纪录1000人</li><li>显示联系人：显示通讯录中所有联系人的信息</li><li>删除联系人：按照 <em>姓名</em> 删除指定联系人</li><li>查找联系人：按照 <em>姓名</em> 查找指定联系人信息</li><li>修改联系人：按照 <em>姓名</em> 重新修改指定联系人</li><li>清空联系人：清空通讯录中所有信息</li><li>退出通讯录：退出当前使用通讯录</li></ul><hr><h2 id="（二）创建项目"><a href="#（二）创建项目" class="headerlink" title="（二）创建项目"></a>（二）创建项目</h2><p>步骤：</p><ul><li>创建新项目</li><li>添加文件</li></ul><hr><h2 id="（三）菜单功能"><a href="#（三）菜单功能" class="headerlink" title="（三）菜单功能"></a>（三）菜单功能</h2><p>功能描述：用户选择功能的界面<br><br>步骤：</p><ul><li>封装函数显示菜单界面</li><li>在main 函数中调用封装好的函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;菜单界面</span><br><span class="line">void show Menu()&#123;</span><br><span class="line">cout&lt;&lt;&quot;*************************&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;***** 1、添加联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;***** 2、显示联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;***** 3、删除联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;***** 4、查找联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;***** 5、修改联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;***** 6、清空联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;***** 0、退出通讯录 *****&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;*************************&quot;&lt;&lt;endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="（四）退出功能实现"><a href="#（四）退出功能实现" class="headerlink" title="（四）退出功能实现"></a>（四）退出功能实现</h2><p>功能描述：退出通讯录系统<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int select &#x3D; 0;&#x2F;&#x2F;创建用户选择输入的变量</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;菜单调用</span><br><span class="line">showMenu();</span><br><span class="line">cin&gt;&gt;select;</span><br><span class="line">switch(select)</span><br><span class="line">&#123;</span><br><span class="line">case 1: &#x2F;&#x2F; 1、添加联系人</span><br><span class="line">break;</span><br><span class="line">case 2: &#x2F;&#x2F; 2、显示联系人</span><br><span class="line">break;</span><br><span class="line">case 3: &#x2F;&#x2F; 3、删除联系人 </span><br><span class="line">break;</span><br><span class="line">case 4: &#x2F;&#x2F; 4、查找联系人</span><br><span class="line">break;</span><br><span class="line">case 5: &#x2F;&#x2F; 5、修改联系人</span><br><span class="line">break;</span><br><span class="line">case 6: &#x2F;&#x2F; 6、清空联系人</span><br><span class="line">break;</span><br><span class="line">case 0: &#x2F;&#x2F; 0、退出通讯录</span><br><span class="line">cout&lt;&lt;&quot;欢迎下次使用”&lt;&lt;endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="（五）添加联系人"><a href="#（五）添加联系人" class="headerlink" title="（五）添加联系人"></a>（五）添加联系人</h2><p>实现步骤：</p><ul><li>设计联系人结构体（基本信息）</li><li>设计通讯录结构体（数量）</li><li>main函数中创建通讯录（创建通讯录变量）</li><li>封装添加联系人函数</li><li>测试添加联系人功能</li></ul><blockquote><p>代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void addpeople(peoplebook* abs)</span><br><span class="line">&#123;</span><br><span class="line">    if (abs-&gt;size &#x3D;&#x3D; max)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;联系人已满，无法添加&quot; &lt;&lt; endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        string name;</span><br><span class="line">        cout &lt;&lt; &quot;请输入名字： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; name;</span><br><span class="line">        abs-&gt;peoplearray[abs-&gt;size].name &#x3D; name;</span><br><span class="line">        string sex;</span><br><span class="line">        </span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;请输入性别： &quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; sex;</span><br><span class="line">            if (sex &#x3D;&#x3D; &quot;男&quot; || sex &#x3D;&#x3D; &quot;女&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                abs-&gt;peoplearray[abs-&gt;size].sex &#x3D; sex; break;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;输入错误，请重新输入&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int age;</span><br><span class="line">        cout &lt;&lt; &quot;请输入年龄： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; age;</span><br><span class="line">        abs-&gt;peoplearray[abs-&gt;size].age &#x3D; age;</span><br><span class="line">        string phone;</span><br><span class="line">        cout &lt;&lt; &quot;请输入联系电话： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; phone;</span><br><span class="line">        abs-&gt;peoplearray[abs-&gt;size].phone &#x3D; phone;</span><br><span class="line">        string map;</span><br><span class="line">        cout &lt;&lt; &quot;请输入联系地址： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; map;</span><br><span class="line">        abs-&gt;peoplearray[abs-&gt;size].map &#x3D; map;</span><br><span class="line">        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl;</span><br><span class="line">        abs-&gt;size++;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="（六）显示联系人"><a href="#（六）显示联系人" class="headerlink" title="（六）显示联系人"></a>（六）显示联系人</h2><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void showpeople(peoplebook* abs)</span><br><span class="line">&#123;</span><br><span class="line">    if (abs-&gt;size &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;对不起，未添加联系人，请添加联系人&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;abs-&gt;size;++i)</span><br><span class="line">        &#123; </span><br><span class="line">        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[i].name &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;性别： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[i].sex &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[i].age &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;联系电话： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[i].phone &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;联系地址： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[i].map &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="（七）删除联系人"><a href="#（七）删除联系人" class="headerlink" title="（七）删除联系人"></a>（七）删除联系人</h2><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void delpeople(peoplebook* abs)</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    int res &#x3D; ispeople(name, abs);</span><br><span class="line">    if (res &#x3D;&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if(res !&#x3D; -1) &#123;</span><br><span class="line">        for (int i &#x3D; res;i &lt; abs-&gt;size;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            abs-&gt;peoplearray[i] &#x3D; abs-&gt;peoplearray[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line">        abs-&gt;size--;</span><br><span class="line">        cout &lt;&lt; &quot;删除成功！！！&quot; &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="（八）查找联系人"><a href="#（八）查找联系人" class="headerlink" title="（八）查找联系人"></a>（八）查找联系人</h2><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void chapeople(peoplebook* abs)</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    int res &#x3D; ispeople(name, abs);</span><br><span class="line">    if (res &#x3D;&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (res !&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[res].name &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;性别： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[res].sex &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[res].age &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;联系电话： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[res].phone &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;联系地址： &quot; &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        cout &lt;&lt; abs-&gt;peoplearray[res].map &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="（九）修改联系人"><a href="#（九）修改联系人" class="headerlink" title="（九）修改联系人"></a>（九）修改联系人</h2><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void modifypeople(peoplebook* abs)</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    int res &#x3D; ispeople(name, abs);</span><br><span class="line">    if (res &#x3D;&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (res !&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        string name;</span><br><span class="line">        cout &lt;&lt; &quot;请输入名字： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; name;</span><br><span class="line">        abs-&gt;peoplearray[res].name &#x3D; name;</span><br><span class="line">        string sex;</span><br><span class="line"> </span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;请输入性别： &quot; &lt;&lt; endl;</span><br><span class="line">            cin &gt;&gt; sex;</span><br><span class="line">            if (sex &#x3D;&#x3D; &quot;男&quot; || sex &#x3D;&#x3D; &quot;女&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                abs-&gt;peoplearray[res].sex &#x3D; sex; break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;输入错误，请重新输入&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int age;</span><br><span class="line">        cout &lt;&lt; &quot;请输入年龄： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; age;</span><br><span class="line">        abs-&gt;peoplearray[res].age &#x3D; age;</span><br><span class="line">        string phone;</span><br><span class="line">        cout &lt;&lt; &quot;请输入联系电话： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; phone;</span><br><span class="line">        abs-&gt;peoplearray[res].phone &#x3D; phone;</span><br><span class="line">        string map;</span><br><span class="line">        cout &lt;&lt; &quot;请输入联系地址： &quot; &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; map;</span><br><span class="line">        abs-&gt;peoplearray[res].map &#x3D; map;</span><br><span class="line">        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="（十）清空通讯录"><a href="#（十）清空通讯录" class="headerlink" title="（十）清空通讯录"></a>（十）清空通讯录</h2><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void cleanpeople(peoplebook* abs)</span><br><span class="line">&#123;</span><br><span class="line">    abs-&gt;size &#x3D; 0;</span><br><span class="line">    cout &lt;&lt; &quot;已清空完毕&quot; &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、C-核心编程"><a href="#三、C-核心编程" class="headerlink" title="三、C++核心编程"></a>三、C++核心编程</h1><h2 id="（一）内存区分模型"><a href="#（一）内存区分模型" class="headerlink" title="（一）内存区分模型"></a>（一）内存区分模型</h2><p>程序执行时，内存大致划分为：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若不释放，结束时由操作系统回收</li></ul><h3 id="1、程序运行前"><a href="#1、程序运行前" class="headerlink" title="1、程序运行前"></a>1、程序运行前</h3><p>在程序编译后，生成了exe可执行程序，<em>未执行该程序</em> 分为*<strong>代码区*** （存放CPU执行的机器指令）和 *</strong>全局区 *** （存放全局变量和静态变量&lt;在普通变量前加static&gt;）</p><blockquote><p> 注意： </p></blockquote><ul><li><p>代码区是共享的，对于被频繁执行的程序，只需要在内存中有一份代码即可</p></li><li><p>代码区是只读的，防止程序意外更改了指令</p></li><li><p>全局区的数据在程序结束后由操作系统释放</p></li><li><p>全局区包含常量区，字符串常量和其他常量（const修饰的全局常量）也存放于此</p></li><li><p>–</p><h3 id="2、程序运行后"><a href="#2、程序运行后" class="headerlink" title="2、程序运行后"></a>2、程序运行后</h3><p>程序运行后划分的区域为*<strong>堆区*** 和*</strong>栈区***</p><blockquote><p>注意：</p></blockquote></li><li><p>栈区数据不要返回局部变量的地址</p></li><li><p>栈区开辟的数据由编译器自动释放</p></li><li><p>利用new关键字可以将数据开辟到堆区</p></li><li><p>指针本质也是局部变量，放在栈上，指针保存的数据放在堆区</p></li></ul><hr><h3 id="3、new操作符"><a href="#3、new操作符" class="headerlink" title="3、new操作符"></a>3、new操作符</h3><p>用途： 利用new关键字可以将数据开辟到堆区<BR><br><em>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <code>delete</code></em><br><br>语法:  <code>new 数据类型 </code></p><hr><h2 id="（二）引用"><a href="#（二）引用" class="headerlink" title="（二）引用"></a>（二）引用</h2><h3 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h3><p>作用：给变量起名<br><br>语法：<code>数据类型 &amp;别名 = 原名</code></p><hr><h3 id="2、注意事项"><a href="#2、注意事项" class="headerlink" title="2、注意事项"></a>2、注意事项</h3><p>1）引用必须初始化<br><br>2）引用在初始化后，不可以改变</p><hr><h3 id="3、引用做函数参数"><a href="#3、引用做函数参数" class="headerlink" title="3、引用做函数参数"></a>3、引用做函数参数</h3><p>作用：函数传参时，可以利用引用的技术让形参修饰实参<br><br>优点：可以简化指针修改实参<br><br>注意：通过引用参数产生的效果同按地址传递时一样的，引用的语法更清楚简单</p><hr><h3 id="4、引用做函数返回值"><a href="#4、引用做函数返回值" class="headerlink" title="4、引用做函数返回值"></a>4、引用做函数返回值</h3><p>作用：做函数返回值<br><br><strong><em>注意：不要返回局部变量引用</em></strong><br><br>用法：函数调用作为左值</p><hr><h3 id="5、引用的本质"><a href="#5、引用的本质" class="headerlink" title="5、引用的本质"></a>5、引用的本质</h3><p> 在C++内部实现是一个指针常量</p><hr><h3 id="6、常量引用"><a href="#6、常量引用" class="headerlink" title="6、常量引用"></a>6、常量引用</h3><p> 作用：常量引用修饰形参，防止误操作<br><br> <em>在函数形参列表中，可以加const修饰形参，防止形参改变实参</em></p><hr><h2 id="（三）函数提高"><a href="#（三）函数提高" class="headerlink" title="（三）函数提高"></a>（三）函数提高</h2><h3 id="1、函数默认参数"><a href="#1、函数默认参数" class="headerlink" title="1、函数默认参数"></a>1、函数默认参数</h3><p>语法：<code>返回值类型 函数名 （参数 = 默认值）&#123;&#125;</code></p><hr><h3 id="2、函数占位参数"><a href="#2、函数占位参数" class="headerlink" title="2、函数占位参数"></a>2、函数占位参数</h3><p> 注意：调用函数时必须填补占位<br><br> 语法：<code>返回值类型 函数名 （数据类型）&#123;&#125;</code></p><hr><h3 id="3、函数重载"><a href="#3、函数重载" class="headerlink" title="3、函数重载"></a>3、函数重载</h3><h4 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h4><p> 作用：函数名可以相同，提高复用性<br><br> 函数重载满足条件:</p><ul><li>同一作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong></li></ul><p>注意：函数的返回值不可以做为函数重载的条件</p><h4 id="（2）注意事项"><a href="#（2）注意事项" class="headerlink" title="（2）注意事项"></a>（2）注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><hr><h2 id="（四）类和对象"><a href="#（四）类和对象" class="headerlink" title="（四）类和对象"></a>（四）类和对象</h2><p>C++面向对象的三大特性：*<strong>封装、继承、多态***<br><br>*</strong>万事万物皆为对象*<strong><br><br>具有相同性质的<em>对象</em>，称为**<em>类</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;&#x2F;&#x2F;&#x2F;这叫定义类</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   A a;&#x2F;&#x2F;&#x2F;这叫声明对象，对象就是a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h3><h4 id="1）意义"><a href="#1）意义" class="headerlink" title="1）意义"></a>1）意义</h4><ul><li>将属性和行为作为一个整体，表现生活中的事物<br><pre><code>  语法：class 类名&#123; 访问权限： 属性/行为 &#125;；</code></pre></li><li>将属性和行为加以权限控制<br><br>访问权限有:  <ul><li>public（公共权限）成员、类内外都可访问</li><li>protected（保护权限）成员、类内可访问，类外不可访问，儿子可以访问父亲的保护内容</li><li>private（私有权限）成员、类内可访问，类外不可访问，儿子不可以访问父亲的私有内容</li></ul></li></ul><h4 id="2）struct和class区别"><a href="#2）struct和class区别" class="headerlink" title="2）struct和class区别"></a>2）struct和class区别</h4><p><strong>默认的访问权限不同</strong><br><br>区别：</p><ul><li>struct默认为公共</li><li>class默认为私有</li></ul><h4 id="3）成员属性设置为私有"><a href="#3）成员属性设置为私有" class="headerlink" title="3）成员属性设置为私有"></a>3）成员属性设置为私有</h4><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限<br><br>优点2：对于写权限，我们可以检测数据的有效性</p><hr><h3 id="2、对象的初始化和清理"><a href="#2、对象的初始化和清理" class="headerlink" title="2、对象的初始化和清理"></a>2、对象的初始化和清理</h3><h4 id="1）构造函数和析构函数"><a href="#1）构造函数和析构函数" class="headerlink" title="1）构造函数和析构函数"></a>1）构造函数和析构函数</h4><p>如果不提供构造和析构，编译器会提供编译器提供的提供的构造函数和析构函数是空实现。</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用</li><li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作</li></ul><p>构造函数语法：<code>类名（）&#123;&#125;</code><br><br>析构函数语法：<code>~类名（）&#123;&#125;</code></p><h4 id="2）构造函数的分类及调用"><a href="#2）构造函数的分类及调用" class="headerlink" title="2）构造函数的分类及调用"></a>2）构造函数的分类及调用</h4><p>两种分类方式:</p><ul><li>按参数：有参、无参构造</li><li>按类型：普通构造、拷贝构造</li></ul><p>三种调用方式：</p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><h4 id="3）拷贝构造函数调用时机"><a href="#3）拷贝构造函数调用时机" class="headerlink" title="3）拷贝构造函数调用时机"></a>3）拷贝构造函数调用时机</h4><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><h4 id="4）构造函数调用规则"><a href="#4）构造函数调用规则" class="headerlink" title="4）构造函数调用规则"></a>4）构造函数调用规则</h4><ul><li>若定义有参构造函数，C++不提供默认无参构造，但是会提供默认拷贝构造</li><li>定义拷贝构造函数，C++不会再提供其他构造函数</li></ul><h4 id="5）深拷贝和浅拷贝"><a href="#5）深拷贝和浅拷贝" class="headerlink" title="5）深拷贝和浅拷贝"></a>5）深拷贝和浅拷贝</h4><p>浅拷贝：简单的赋值拷贝操作<br><br>深拷贝：在堆区重新申请空间，进行拷贝操作<br><br>注意：如果属性有在堆区开辟，要提供拷贝构造函数，防止带来问题</p><h4 id="6）初始化列表"><a href="#6）初始化列表" class="headerlink" title="6）初始化列表"></a>6）初始化列表</h4><p>作用：C++提供了初始化列表语法，用来初始化列表语法，用来初始化属性<br><br>语法：<code>构造函数（）：属性1（值1）,属性2（值2）...&#123;&#125;</code></p><h4 id="7）类对象作为类成员"><a href="#7）类对象作为类成员" class="headerlink" title="7）类对象作为类成员"></a>7）类对象作为类成员</h4><p><strong>C++中的成员可以是另一个类的对象，称为对象成员</strong><br><br>构造顺序：先调用对象成员的构造，再调用本类构造<br><br>注意：析构顺序和构造相反</p><h4 id="8）静态成员"><a href="#8）静态成员" class="headerlink" title="8）静态成员"></a>8）静态成员</h4><p>在成员变量和成员函数前加上关键字static，称为静态成员<br><br>分类：</p><ul><li><p>静态成员变量</p><ul><li>所有对象共享一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li><p>静态成员函数</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul><hr><h3 id="3、C-对象模型和this指针"><a href="#3、C-对象模型和this指针" class="headerlink" title="3、C++对象模型和this指针"></a>3、C++对象模型和this指针</h3><h4 id="1）成员变量和成员函数分开存储"><a href="#1）成员变量和成员函数分开存储" class="headerlink" title="1）成员变量和成员函数分开存储"></a>1）成员变量和成员函数分开存储</h4><p> 注意：</p></li><li><p>空对象占用内存：1</p></li><li><p>C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</p></li><li><p>每个空对象也应该有一个独一无二的内存地址</p><p>在C++中，只有非静态成员变量才属于类的对象上</p><h4 id="2）this指针概念"><a href="#2）this指针概念" class="headerlink" title="2）this指针概念"></a>2）this指针概念</h4></li></ul><p> <strong>this指针指向被调用的成员函数所需的对象</strong><br> 概念：this指针是隐含每一个非静态成员函数内的一种指针<br><br> 注意：this指针不需要定义，可直接使用<br><br> 用途：</p><ul><li><p>当形参和成员变量同名时，可用this指针来区分</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用return*this</p><h4 id="3）空指针访问成员函数"><a href="#3）空指针访问成员函数" class="headerlink" title="3）空指针访问成员函数"></a>3）空指针访问成员函数</h4><p>空指针可以调用成员函数，但要注意有无用到this指针</p><h4 id="4）const修饰成员函数"><a href="#4）const修饰成员函数" class="headerlink" title="4）const修饰成员函数"></a>4）const修饰成员函数</h4></li><li><p>常函数（成员函数后加const；不可修改成员属性，成员属性声明加mutable可以修改）</p></li><li><p>常对象（声明对象前加const；只能调用常函数）</p></li></ul><hr><h3 id="4、友元"><a href="#4、友元" class="headerlink" title="4、友元"></a>4、友元</h3><p> 关键字：friend<br><br> 实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><hr><h3 id="5、运算符重载"><a href="#5、运算符重载" class="headerlink" title="5、运算符重载"></a>5、运算符重载</h3><ul><li><p>改变运算符的运算过程叫运算符重载。</p></li><li><p> 运算符重载分为普通运算符重载(“ + ”、“ - ”、“ * ”、“ / ”等)、前置运算符重载(“++”、”–”)、后置运算符重载(“++”、”–”)、插入运算符重载(“&gt;&gt;”)、提取运算符重载(“&lt;&lt;”)</p></li><li><p>重载运算符的方式：<br><br>令运算符重载函数作为类的成员函数</p><p>令运算符重载函数作为类的友元函数</p></li><li><p>区别：令运算符重载函数作为类的成员函数在调用时只需输入一个被操作数参数即可，另一个操作数参数则不需要输入；令运算符重载函数作为类的友元函数在调用时不仅要求输入被操作数参数，还要求输入被操作数参数。产生了这个区别的原因在于令运算符重载函数作为类的成员函数和令运算符重载函数作为类的友元函数有本质区别：</p><p>  (Ⅰ)调用作为类的成员函数的运算符重载函数时，类对象肯定已经被建立了，这时对象中对应的私有数据成员存在。</p><p>  (Ⅱ)调用作为类的友元函数的运算符重载函数时，类对象还未被建立，这时对象中对应私有数据成员不存在。</p></li><li><p>定义的类和其他数据类型之间的转换：定义转换构造函数可以将一个指定类型的数据转换为类的对象（不可以反过来转换）；定义类型转换函数可以将一个类的对象转换成其他类型的数据（不可以反过来转换）</p></li></ul><hr><h3 id="6、继承"><a href="#6、继承" class="headerlink" title="6、继承"></a>6、继承</h3><p> 继承是类的重要特性。<br><br> A类继承B类，我称B类为“基类”，A为“子类”。A类继承了B类之后，A类就具有了B类的部分成员，具体得到了那些成员，这得由两个方面决定：</p><ul><li>继承方式</li><li>基类成员的访问权限</li></ul><p>继承方式：</p><ul><li><strong>公有继承方式（public）</strong><blockquote><p>示例</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    Student(string s, int g,int a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Constuct Student&quot; &lt;&lt; endl;</span><br><span class="line">        name &#x3D; s;</span><br><span class="line">        grade &#x3D; g;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Student:&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;grade&#x3D;&quot; &lt;&lt; grade&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; &quot;age&#x3D;&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    string name;</span><br><span class="line">    int grade;</span><br><span class="line">private:</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GraduateStudent :public Student                        &#x2F;&#x2F;继承方式i</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    GraduateStudent(string s, int g, int a) :Student(s, g, a)   &#x2F;&#x2F;调用基类的构造函数，构造基类</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Constuct GraduateStudent&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;*</span><br><span class="line">    公有继承方式，会把基类的公有成员（变量和函数）继承到子类公有成员，保护成员</span><br><span class="line">    变成基类的保护成员，但是私有成员子类也一样不可以访问</span><br><span class="line">    *&#x2F;</span><br><span class="line">    void print1()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;GraduateStudent:&quot; &lt;&lt; endl;                           </span><br><span class="line">        cout &lt;&lt; &quot;name&#x3D; &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;grade&#x3D; &quot; &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    GraduateStudent g(&quot;Ouyang&quot;, 95, 21);</span><br><span class="line">    g.print();                     &#x2F;&#x2F;子类可以直接访问基类公共成员成员</span><br><span class="line">    g.print1();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>保护继承（protected）</strong><blockquote><p>示例</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">    Student(string s, int g,int a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Constuct Student&quot; &lt;&lt; endl;</span><br><span class="line">        name &#x3D; s;</span><br><span class="line">        grade &#x3D; g;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Student:&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;grade&#x3D;&quot; &lt;&lt; grade&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; &quot;age&#x3D;&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string name;   &#x2F;&#x2F;公有成员</span><br><span class="line">    int grade;</span><br><span class="line">private:</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GraduateStudent :protected Student                        &#x2F;&#x2F;继承方式i</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    GraduateStudent(string s, int g, int a) :Student(s, g, a)   &#x2F;&#x2F;调用基类的构造函数，构造基类</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Constuct GraduateStudent&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;*</span><br><span class="line">    保护继承方式，会把基类的公有成员或者保护成员（变量和函数）变成子类的保护成员，但是私有成员子类也一样不可以访问</span><br><span class="line">    *&#x2F;</span><br><span class="line">    void print1()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;GraduateStudent:&quot; &lt;&lt; endl;                           </span><br><span class="line">        cout &lt;&lt; &quot;name&#x3D; &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;grade&#x3D; &quot; &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    GraduateStudent g(&quot;Ouyang&quot;, 95, 21);</span><br><span class="line">    &#x2F;&#x2F;g.print();   编译出错                  无法直接访问子类的公有成员了</span><br><span class="line">    g.print1();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>私有继承（private）</strong><br><br>私有继承方式的，就是在继承时，把protected变成private<br></li></ul><p><strong>派生类</strong>：<br>派生类是通过调用基类的构造函数，实现对成员变量的初始化。</p><hr><h3 id="7、多态"><a href="#7、多态" class="headerlink" title="7、多态"></a>7、多态</h3><p>定义：允许将子类类型的指针赋值给父类类型的指针。<br><br>实现方式 : <strong>覆盖</strong> ，<strong>重载</strong> 。<br>覆盖：是指子类重新定义父类的虚函数的做法。<br>重载：是指允许存在多个同名函数，而这些函数的参数表不同<br><br>构成条件：</p><ul><li>调用函数的对象必须是指针或者引用；</li><li>被调用的函数必须是虚函数，且完成了虚函数的重写。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：重写虚函数时一定要保证函数的返回值，参数列表，函数名称完全一致</span><br></pre></td></tr></table></figure></li><li><strong>使用虚函数实现多态示例</strong></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> #ifndef student_hpp</span><br><span class="line">#define student_hpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Student&#123;</span><br><span class="line">private:</span><br><span class="line">    int mAge;</span><br><span class="line">    string mName;</span><br><span class="line">protected:</span><br><span class="line">    int mClazz;</span><br><span class="line">public:</span><br><span class="line">    Student() &#123;&#125;;</span><br><span class="line">    void setName(const string &amp;age);</span><br><span class="line">    string getName() const;</span><br><span class="line">    void setAage(int &amp;age);</span><br><span class="line">    int getAge() const;</span><br><span class="line">    virtual void setClassMate(int num)&#123;</span><br><span class="line">        mClazz&#x3D;num;</span><br><span class="line">        std::cout&lt;&lt;“call parent method”&lt;&lt;std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    virtual int getClassMate()&#123;</span><br><span class="line">        return mClazz;</span><br><span class="line">    &#125;;</span><br><span class="line">    virtual ~Student() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="（五）文件操作"><a href="#（五）文件操作" class="headerlink" title="（五）文件操作"></a>（五）文件操作</h2><p>包含头文件： &lt; fstream &gt;</p><p><strong>文本文件</strong> ：文件以文本的ASCⅡ码形式存储在计算机中<br><strong>二进制文件</strong>：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂他们</p><p>操作文件的三大类：</p><ul><li>ofstream : 写操作</li><li>ifstream : 读操作</li><li>fstream : 读写操作</li></ul><h3 id="1、写文件"><a href="#1、写文件" class="headerlink" title="1、写文件"></a>1、写文件</h3><p>步骤：</p><ul><li>包含头文件<br><br><code>#include&lt; fstream&gt;</code></li><li>创建流对象<br><br><code>ofstream ofs;</code></li><li>打开文件</li><li>关闭文件</li></ul><p>注意：文件打开方式可以配合使用，利用|操作符</p><h3 id="2、读文件"><a href="#2、读文件" class="headerlink" title="2、读文件"></a>2、读文件</h3><p>步骤与写文件步骤相似，但读取方式相对较多，且打开文件时需判断文件是否打开成功，读数据有四种方式读取</p><h3 id="3、二进制文件"><a href="#3、二进制文件" class="headerlink" title="3、二进制文件"></a>3、二进制文件</h3><p>以二进制的方式对文件进行读写操作<br><br>打开方式指定为: <code>ios::binary</code></p><h4 id="1）写文件"><a href="#1）写文件" class="headerlink" title="1）写文件"></a>1）写文件</h4><p>主要利用流对象调用成员函数write</p><h4 id="2）读文件"><a href="#2）读文件" class="headerlink" title="2）读文件"></a>2）读文件</h4><p>主要利用流对象调用成员函数read</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/wozenmehaibuxiangqushui.github.io/2021/01/22/hello-world/"/>
      <url>/wozenmehaibuxiangqushui.github.io/2021/01/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
